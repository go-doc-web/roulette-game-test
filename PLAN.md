ехнічне Завдання: Інтерактивна Веб-Гра "Рулетка Double" (MVP)

### 1. Мета Проєкту

Розробити інтерактивну веб-гру "Рулетка Double", що є MVP (Minimum Viable Product), аналогічний режиму Double на Clash.gg. Проєкт має на меті продемонструвати ключові навички у сучасному веб-розробленні, включаючи анімацію, інтеграцію з базою даних, та ефективне управління станом. MVP буде симулювати обертання рулетки, визначати переможця, показувати історію ігор та статистику, а також відображати симуляцію ставок "фейкових" користувачів. Проєкт орієнтований на деплой на Vercel з використанням PostgreSQL (Vercel Postgres) та Prisma ORM. Архітектура повинна дозволяти легке розширення функціоналу в майбутньому (наприклад, додавання реальної авторизації, балансу, WebSockets).

### 2. Основний Стек Технологій

- **Фронтенд:**
  - **React 19.0.0:** Бібліотека для побудови користувацького інтерфейсу.
  - **Next.js 14+ (App Router):** Фреймворк для React, що підтримує Server Components, Client Components та API Routes.
  - **TypeScript 5+:** Мова програмування для статичної типізації коду.
  - **Tailwind CSS 4.1.8:** Утилітарний CSS-фреймворк для швидкої та послідовної стилізації.
  - **Framer Motion 12.16.0:** Бібліотека для декларативних анімацій (обертання рулетки, виділення переможця).
  - **clsx 2.1.1:** Утиліта для умовного об'єднання CSS-класів.
  - **uuid 11.1.0:** Для генерації унікальних ідентифікаторів.
  - **Zustand:** Легка та швидка бібліотека для управління глобальним станом (історія виграшів, дані ставок, стан обертання).
- **Бекенд (API Routes у Next.js):**
  - **Node.js:** Середовище виконання для API Routes.
  - **Prisma ORM:** Для взаємодії з базою даних.
- **База Даних:**
  - **PostgreSQL:** Реляційна СУБД.
  - **Vercel Postgres:** Хмарний сервіс PostgreSQL для деплою на Vercel (використовує Neon).
- **Хостинг/Деплой:**
  - **Vercel:** Платформа для розгортання Next.js додатків.
- **Інструменти розробки:**
  - ESLint, Prettier: Для забезпечення якості та консистентності коду.

### 3. Головні Користувацькі Сценарії (User Stories)

- **Як користувач, я хочу бачити візуальне обертання рулетки та відлік часу до початку наступного раунду,** щоб розуміти поточний стан гри.
- **Як користувач, я хочу бачити панель активних ставок з фейковими користувачами,** щоб відчувати динаміку гри та бачити, хто і скільки "поставив" на різні кольори.
- **Як користувач, я хочу бачити результат раунду (переможний колір/фішку),** щоб дізнатися, хто "виграв".
- **Як користувач, я хочу бачити історію останніх ігор (переможні фішки) та їх статистику,** щоб аналізувати попередні результати.

### 4. Фічі з Чітким Описом Поведінки

#### 4.1. Механіка Рулетки

- **Рулетка (UI):**
  - Візуальне представлення рулетки з визначеним набором фішок (комірок) різних кольорів (червоний, чорний, зелений, джокер).
  - **Поведінка:** Рулетка анімовано обертається протягом фіксованого часу (константа). Після зупинки, переможна фішка виділяється.
  - **Відлік часу:** Відображається відлік часу до початку наступного раунду.
- **API `/api/roulette` (Next.js API Route - Serverless Function):**
  - **Призначення:** Запускає новий раунд рулетки, визначає переможця та зберігає дані.
  - **Логіка:**
    - Генерує випадкову послідовність фішок (`Cell[]`) та випадковий індекс переможця (`number`).
    - Зберігає інформацію про переможця (мінімум: `id`, `color`, `timestamp`) у таблиці `Winner` у PostgreSQL через Prisma.
    - Реалізує логіку "кругового буфера": якщо кількість записів у таблиці `Winner` перевищує `MAX_WINNERS_COUNT` (наприклад, 300), видаляє найстаріші записи.
  - **Відповідь (JSON):** `{ sequence: Cell[], winnerIndex: number, newWinner: { id: string; color: string; timestamp: Date; } }`

#### 4.2. Панель Активних Ставок (Фейкові Користувачі)

- **Панель Ставок (UI):**
  - Візуально розділена на колонки для кожного кольору (Червоний, Зелений, Чорний, Джокер).
  - **Інформація в кожній колонці:**
    - Назва кольору та відповідний множник виплати (наприклад, "BET ON RED PAYS 2X", "PAYS 4X", "PAYS 7X").
    - Загальна кількість "ставок" на цей колір.
    - Загальна "сума ставок" на цей колір.
    - Короткий список індивідуальних "ставок" (наприклад, 4-5 останніх/найбільших) з "іменем користувача" (простий фейковий ID) та "сумою ставки".
  - **Поведінка:** Дані на панелі оновлюються на початку кожного нового раунду, симулюючи нові ставки.
- **API `/api/bets` (Next.js API Route - Serverless Function):**
  - **Призначення:** Генерує тимчасові, фейкові дані ставок для поточного раунду.
  - **Логіка:**
    - Генерує випадкову кількість "ставок" для раунду (наприклад, від 5 до 20).
    - Для кожної ставки випадково визначає `color`, `amount` (наприклад, від 0.50 до 250.00) та унікальний фейковий `userId`.
    - Агрегує згенеровані ставки за кольорами (підрахунок загальної суми та кількості ставок).
    - Відбирає декілька індивідуальних ставок для відображення у кожній колонці.
  - **Відповідь (JSON):** `{ bets: AggregatedBets[] }` (де `AggregatedBets` - масив об'єктів для кожного кольору, що містить `color`, `payoutMultiplier`, `totalAmount`, `totalBetsCount`, `individualBets`).
  - **Примітка:** Ці дані не зберігаються в базу даних, а генеруються "на льоту" для симуляції.

#### 4.3. Історія Ігор та Статистика

- **Історія Виграшів (UI):**
  - **Візуалізація:** Панель, що відображає список останніх 300 виграшних фішок (кольорів) у зворотному хронологічному порядку (найновіші зверху).
  - **Поведінка:** Оновлюється автоматично, коли новий раунд завершується.
- **Статистика Виграшів (UI):**
  - **Візуалізація:** Панель, що відображає підсумкову статистику на основі останніх 300 ігор.
  - **Показники:** Кількість випадань для кожного кольору (червоний, чорний, зелений, джокер).
- **API `/api/roulette/history` (Next.js API Route - Serverless Function):**
  - **Призначення:** Отримання історії виграшів.
  - **Логіка:** Витягує останні `MAX_WINNERS_COUNT` записів з таблиці `Winner` у PostgreSQL, відсортованих за `timestamp` у спадаючому порядку, використовуючи Prisma.
  - **Відповідь (JSON):** `{ winners: Winner[] }` (масив об'єктів `Winner`).

### 5. Структура Проєкту (Feature-based)

```
/
├── app/
│   ├── api/
│   │   ├── bets/
│   │   │   └── route.ts         // API для генерації фейкових ставок
│   │   ├── roulette/
│   │   │   ├── history/
│   │   │   │   └── route.ts     // API для отримання історії виграшів з БД
│   │   │   └── route.ts         // API для обертання рулетки, визначення переможця та збереження в БД
│   ├── page.tsx                 // Головна сторінка Home (клієнтський компонент, що координує гру)
│   └── layout.tsx               // Загальний лейаут додатка
├── components/
│   ├── ui/                      // Дрібні, перевикористовувані UI компоненти (наприклад, Button, Spinner)
│   │   └── Spinner.tsx
│   ├── ActiveBetsPanel.tsx      // Компонент панелі активних ставок з фейковими користувачами
│   ├── RouletteProgress.tsx     // Компонент індикатора прогресу/часу до наступного раунду
│   ├── RouletteSlider.tsx       // Компонент візуалізації та анімації рулетки
│   ├── RouletteStatistics.tsx   // Компонент відображення статистики виграшів
│   └── WinnersHistory.tsx       // Компонент відображення історії виграшів
├── lib/
│   ├── buildCells.ts            // Логіка для генерації структури фішок рулетки
│   ├── rouletteSequence.ts      // Визначення послідовності фішок рулетки
│   ├── prisma.ts                // Ініціалізація PrismaClient (для уникнення множинних інстансів)
│   └── utils.ts                 // Загальні допоміжні функції
├── constants/
│   └── index.ts                 // Глобальні константи (MAX_WINNERS_COUNT, ROULETTE_UPDATE_INTERVAL_MS, кольори рулетки, множники виплат)
├── prisma/
│   ├── schema.prisma            // Схема бази даних Prisma (визначення моделі Winner)
│   └── migrations/              // Міграції бази даних Prisma
├── store/
│   └── rouletteStore.ts         // Zustand стор для глобального стану (історія, ставки, статус гри)
├── types/
│   └── index.ts                 // Глобальні TypeScript типи та інтерфейси (Cell, Bet, AggregatedBets, Winner)
├── public/                      // Статичні ассети (наприклад, favicon)
├── styles/
│   └── globals.css              // Глобальні стилі (Tailwind CSS)
├── .env.local                   // Змінні оточення для локальної розробки (gitignore)
├── next.config.js               // Конфігурація Next.js
├── tailwind.config.ts           // Конфігурація Tailwind CSS
├── tsconfig.json                // Конфігурація TypeScript
└── package.json                 // Залежності та скрипти проєкту
```

### 6. API-Ендпоінти (Next.js API Routes)

- **`GET /api/roulette`:** Генерує новий раунд, визначає переможця, зберігає його в БД, повертає дані.
- **`GET /api/roulette/history`:** Повертає останні 300 виграшів з БД.
- **`GET /api/bets`:** Генерує та повертає фейкові активні ставки для поточного раунду.

### 7. План Розробки по Етапах (Step-by-Step)

#### Етап 1: Налаштування Проєкту та Базовий API з БД (30%)

1. **Початкове налаштування:** Переконатися, що Next.js 14+ (App Router), React 19+, TypeScript, Tailwind CSS, Framer Motion коректно встановлені та налаштовані. Налаштувати ESLint і Prettier.
2. **Інтеграція Vercel Postgres:**
   - Створити проєкт на Vercel та підключити до нього Vercel Postgres через дашборд.
   - Перевірити змінні оточення (`DATABASE_URL`, `POSTGRES_PRISMA_URL`).
3. **Налаштування Prisma:**
   - Встановити `prisma` та `@prisma/client`.
   - Ініціалізувати Prisma (`npx prisma init`).
   - Визначити модель `Winner` у `prisma/schema.prisma` з полями `id: String @id @default(uuid())`, `color: String`, `timestamp: DateTime @default(now())`.
   - Застосувати міграцію (`npx prisma db push`).
4. **Модифікація API `/api/roulette`:**
   - Реалізувати логіку збереження нового виграшу до БД за допомогою `prisma.winner.create()`.
   - Додати логіку "кругового буфера" (видалення найстаріших записів при перевищенні `MAX_WINNERS_COUNT`).
   - Оновити відповідь API для повернення `newWinner`.
5. **Створення API `/api/roulette/history`:**
   - Створити маршрут, який отримує останні `MAX_WINNERS_COUNT` виграшів з БД за допомогою `prisma.winner.findMany()`.

#### Етап 2: Управління Станом (Zustand) та Оновлення Фронтенду (30%)

1. **Впровадження Zustand:**
   - Встановити `zustand`.
   - Створити `store/rouletteStore.ts` для управління глобальним станом гри (`winnersHistory`, `latestWinner`, `isRolling`, `timeToNextRound`, `betsData`) та визначити відповідні action-функції.
2. **Оновлення `app/page.tsx` (головний компонент):**
   - Змінити використання `useState` на `useRouletteStore()` для основних станів.
   - Модифікувати `fetchRouletteData` для виклику `/api/roulette` та оновлення стану в Zustand.
   - Додати логіку керування відліком часу до наступного раунду через Zustand.
3. **Оновлення `components/WinnersHistory.tsx` та `components/RouletteStatistics.tsx`:**
   - Змінити ці компоненти, щоб вони читали `winnersHistory` та `latestWinner` безпосередньо зі Zustand стору.
   - `WinnersHistory` також буде виконувати початковий `fetch` `/api/roulette/history` для ініціалізації історії в Zustand сторі.

#### Етап 3: Реалізація Панелі Ставок (30%)

1. **Визначення Типів Даних для Ставок:**
   - Створити TypeScript інтерфейси `Bet` та `AggregatedBets` у `types/index.ts`.
2. **Створення API `/api/bets`:**
   - Реалізувати маршрут `app/api/bets/route.ts` для генерації фейкових ставок та їх агрегації.
3. **Розробка компонента `components/ActiveBetsPanel.tsx`:**
   - Створити клієнтський React-компонент для відображення панелі.
   - Він буде читати дані `betsData` зі Zustand стору.
4. **Інтеграція в `app/page.tsx`:**
   - Додати `ActiveBetsPanel` до JSX.
   - В `fetchRouletteData` або в окремій функції, яка викликається після раунду, додати логіку виклику `/api/bets` та оновлення `betsData` в Zustand сторі.

#### Етап 4: Фіналізація, Тестування та Деплой (10%)

1. **UX/UI Полірування:**
   - Перевірити адаптивність дизайну на різних пристроях.
   - Забезпечити плавність та коректність всіх анімацій (Framer Motion).
   - Перевірити візуальне відображення всіх станів (завантаження, помилка, порожні дані).
2. **Оптимізація Коду:**
   - Перевірити наявність зайвих ре-рендерів (React DevTools).
   - Забезпечити послідовну типізацію TypeScript.
   - Використати ESLint та Prettier для фінального аудиту та форматування коду.
3. **Функціональне Тестування:**
   - Ретельно протестувати всі API-маршрути та їх взаємодію з фронтендом.
   - Перевірити коректність збереження та відображення історії виграшів.
   - Перевірити правильність генерації та оновлення фейкових ставок.
4. **Деплой:**
   - Зробити фінальний коміт до репозиторію.
   - Розгорнути проєкт на Vercel та перевірити його працездатність у продакшн-середовищі.

### 8. Важливі UX/UI Деталі та Вимоги до Дизайну

- **Візуальна аналогія:** Базова візуальна схожість з режимом Double на Clash.gg для рулетки, панелей історії та ставок.
- **Чітка індикація стану:** Ясні візуальні сигнали для обертання рулетки, активного таймера, виділення переможця.
- **Плавність:** Всі анімації та переходи між станами повинні бути плавними та приємними для ока.
- **Кольорова палітра:** Акцент на кольорах рулетки (червоний, чорний, зелений) та нейтральні фони. Джокер може бути виділений фіолетовим або золотим.
- **Типографія:** Чітка, легко читабельна типографія для чисел, імен та результатів.
- **Адаптивний дизайн:** Повністю адаптивний інтерфейс, що забезпечує коректне відображення та функціональність на всіх пристроях (мобільні, планшети, десктопи).

### 9. Можливі Стани Компонентів

- **Завантаження (Loading):** Відображається під час завантаження початкових даних (наприклад, "Завантаження рулетки...", "Завантаження історії...").
- **Помилка (Error):** Чітке повідомлення про помилку, якщо запит до API не вдався.
- **Пусто (Empty):** Повідомлення, якщо історія виграшів або ставки відсутні (наприклад, "Ще немає виграшів.", "Ставок поки немає.").
- **Активний (Active):** Основний стан, коли рулетка обертається, таймер йде, дані відображаються.

### 10. Рекомендації по Архітектурі та Файловій Структурі

- **Modular Monolith:** Проєкт буде розроблений як монолітний додаток, але з сильним акцентом на модульність та розділення за функціональністю (feature-based).
- **Next.js App Router Paradigms:**
  - **Server Components (за замовчуванням):** Використовуються для рендерингу статичного контенту та початкового завантаження даних (наприклад, в `page.tsx` до додавання `'use client'`).
  - **Client Components (`'use client'`):** Використовуються для інтерактивних елементів, управління станом та обробки подій користувача (більшість ваших компонентів UI).
  - **API Routes:** Використовуються для бекенд-логіки (доступ до БД, генерація даних), що виконується як Serverless Functions на Vercel.
- **Data Fetching:**
  - На сервері (API Routes): пряме використання Prisma Client.
  - На клієнті: `fetch` API.
- **Типізація:** Суворе використання TypeScript для всіх даних, пропсів, станів, функцій та API-відповідей. Це критично для підтримки та масштабованості.
- **Перевикористовувані компоненти:** Дрібні, універсальні UI компоненти (кнопки, спінери) винесені в `components/ui`.
- **Глобальні константи:** Винесення всіх конфігураційних значень (`MAX_WINNERS_COUNT`, інтервали, кольори рулетки, множники) в `constants/index.ts`.

### 11. Потенційні Підводні Камені та Ризики

- **Оптимізація Анімацій:** Забезпечення плавної анімації рулетки на широкому спектрі пристроїв та браузерів. Framer Motion спрощує це, але може знадобитися тонке налаштування.
- **Синхронізація Станів:** Забезпечення коректного та своєчасного оновлення всіх UI-панелей (історії, статистики, ставок) після завершення раунду. Використання Zustand значно мінімізує цей ризик, централізуючи логіку оновлення.
- **Ліміти Безкоштовного Плану:** Хоча для MVP лімітів безкоштовного плану Vercel та Vercel Postgres/Neon буде достатньо, активне використання або розширення функціоналу може вимагати переходу на платний план.
- **Холодний старт (Cold Start) Serverless Functions:** Іноді може бути невелика затримка (кілька сотень мілісекунд) при першому запиті до API після періоду бездіяльності функції. Для рулетки це може бути помітно лише при першому раунді.
- **Масштабованість фейкових даних:** Метод генерації фейкових ставок простий. Для дуже великих масштабів симуляції може знадобитися оптимізація.

### 12. Чеклист Готовності MVP

- [ ] Додаток успішно деплоїться на Vercel.
- [ ] Рулетка візуально обертається, визначає та виділяє переможця з анімацією.
- [ ] Таймер зворотного відліку до наступного раунду відображається коректно.
- [ ] Дані про переможця успішно зберігаються в PostgreSQL через Prisma.
- [ ] Історія виграшів (останні 300 записів) коректно відображається, читаючи дані з БД через API `/api/roulette/history`.
- [ ] Статистика виграшів (за кольорами) коректно обчислюється та відображається на основі історії.
- [ ] Панель "Активні Ставки" відображає фейкові ставки, згенеровані бекендом через API `/api/bets`.
- [ ] Фейкові ставки оновлюються з кожним новим раундом.
- [ ] Всі основні API-маршрути (`/api/roulette`, `/api/roulette/history`, `/api/bets`) працюють без помилок.
- [ ] Управління станом реалізовано за допомогою Zustand.
- [ ] Код написаний на TypeScript, з чіткими типами та інтерфейсами.
- [ ] Забезпечена базова адаптивність UI на мобільних та десктопних пристроях.
- [ ] Оброблені стани завантаження, помилок та порожніх даних.
- [ ] Проєкт відповідає структурі feature-based.
- [ ] Код чистий, читабельний та відформатований (ESLint/Prettier).
